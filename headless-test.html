<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Headless Sampler Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; line-height: 1.4; }
    .ok { color: #0a7f2e; }
    .fail { color: #b00020; }
    #out { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  </style>
</head>
<body>
  <h1>Headless Sampler Test</h1>
  <div id="out">Exécution des tests… Regardez aussi la console.</div>

  <script type="module">
    import { loadAndDecodeSound, playSound } from './js/soundutils.js';

    const out = document.getElementById('out');
    const log = (msg, cls) => {
      const line = document.createElement('div');
      line.textContent = msg;
      if (cls) line.className = cls;
      out.appendChild(line);
      console[cls === 'fail' ? 'error' : 'log'](msg);
    };

    function assert(cond, message) {
      if (!cond) throw new Error(message || 'Assertion failed');
    }

    // Generate a simple mono AudioBuffer (sine wave)
    function makeSineBuffer(ctx, seconds = 1.0, freq = 440) {
      const sr = ctx.sampleRate;
      const length = Math.floor(seconds * sr);
      const buffer = ctx.createBuffer(1, length, sr);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < length; i++) {
        data[i] = Math.sin(2 * Math.PI * freq * (i / sr)) * 0.5; // -6 dBFS
      }
      return buffer;
    }

    // Encode Float32 mono PCM to WAV (16-bit) and return a base64 data URL
    function makeWavDataUrlFromFloat32(float32, sampleRate = 44100) {
      // clamp and convert to 16-bit PCM
      const numSamples = float32.length;
      const bytesPerSample = 2;
      const blockAlign = 1 * bytesPerSample; // mono
      const byteRate = sampleRate * blockAlign;
      const dataSize = numSamples * bytesPerSample;
      const buffer = new ArrayBuffer(44 + dataSize);
      const view = new DataView(buffer);

      // RIFF header
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + dataSize, true);
      writeString(view, 8, 'WAVE');
      // fmt chunk
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true); // PCM chunk size
      view.setUint16(20, 1, true); // PCM format
      view.setUint16(22, 1, true); // mono
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, byteRate, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, 16, true); // bits per sample
      // data chunk
      writeString(view, 36, 'data');
      view.setUint32(40, dataSize, true);

      // PCM samples
      let offset = 44;
      for (let i = 0; i < numSamples; i++, offset += 2) {
        let s = Math.max(-1, Math.min(1, float32[i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      }

      // to base64 data URL
      const u8 = new Uint8Array(buffer);
      let binary = '';
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      const b64 = btoa(binary);
      return `data:audio/wav;base64,${b64}`;

      function writeString(dv, offset, str) {
        for (let i = 0; i < str.length; i++) dv.setUint8(offset + i, str.charCodeAt(i));
      }
    }

    function rms(channelData) {
      let sum = 0;
      for (let i = 0; i < channelData.length; i++) {
        const v = channelData[i]; sum += v * v;
      }
      return Math.sqrt(sum / channelData.length);
    }

    async function testPlaySoundOffline() {
      // Use an OfflineAudioContext to render without output
      const durationSec = 1.0;
      const sampleRate = 44100;
      const length = Math.floor(sampleRate * durationSec);
      const oac = new OfflineAudioContext(1, length, sampleRate);

      const buf = makeSineBuffer(oac, 0.5, 440);
      // Expect non-zero output when rendered
      playSound(oac, buf, 0, buf.duration);
      const rendered = await oac.startRendering();
      const ch0 = rendered.getChannelData(0);
      const val = rms(ch0);
      assert(val > 0.001, `RMS trop faible: ${val}`);
      log(`testPlaySoundOffline: OK (rms=${val.toFixed(4)})`, 'ok');
    }

    function makeSineFloat32(seconds, sampleRate = 44100, freq = 330) {
      const length = Math.floor(seconds * sampleRate);
      const f32 = new Float32Array(length);
      for (let i = 0; i < length; i++) f32[i] = Math.sin(2 * Math.PI * freq * (i / sampleRate)) * 0.5;
      return f32;
    }

    async function testLoadAndDecodeFromDataURL() {
      const seconds = 0.5;
      const sampleRate = 44100;
      // build a simple sine and encode to data: URL WAV (no AudioContext needed)
      const f32 = makeSineFloat32(seconds, sampleRate, 330);
      const url = makeWavDataUrlFromFloat32(f32, sampleRate);

      // decode using the tested helper into an OfflineAudioContext
      const oac = new OfflineAudioContext(1, Math.floor(seconds * sampleRate), sampleRate);
      const decoded = await loadAndDecodeSound(url, oac);
      assert(decoded && decoded.length > 0, 'Décodage a échoué');
      assert(Math.abs(decoded.duration - seconds) < 0.05, `Durée inattendue: ${decoded.duration}`);
      log(`testLoadAndDecodeFromDataURL: OK (duration≈${decoded.duration.toFixed(3)}s)`, 'ok');
    }

    async function run() {
      const results = [];
      const tests = [
        ['Lecture offline via playSound', testPlaySoundOffline],
        ['Décodage via data: URL', testLoadAndDecodeFromDataURL],
      ];
      for (const [name, fn] of tests) {
        try {
          await fn();
          results.push({ name, ok: true });
        } catch (err) {
          log(`${name}: FAIL → ${err && err.message ? err.message : err}`, 'fail');
          results.push({ name, ok: false, err });
        }
      }
      const allOk = results.every(r => r.ok);
      if (allOk) {
        log('Tous les tests headless ont réussi ✅', 'ok');
        document.title = 'Headless Sampler Test — OK';
      } else {
        const fails = results.filter(r => !r.ok).length;
        log(`${fails} test(s) en échec ❌`, 'fail');
        document.title = 'Headless Sampler Test — FAIL';
      }
    }

    run();
  </script>
</body>
</html>
